/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package wavesim;

import java.awt.Color;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

import javax.swing.JPanel;
import javax.swing.SwingUtilities;

public class App extends Frame {

    /* First Test */
    // private int numPoints = 50;
    // private double timeScale = 10000;
    // private int FPS = 5;
    // private double k = 0.1;
    // private double dt = 0.1;
    // private double u = 0;

    /* Second Test */
    // private int numPoints = 50;
    // private double timeScale = 10000;
    // private int FPS = 20;
    // private double k = 1;
    // private double dt = 0.1;
    // private double u = 0.05;

    /* Third Test */
    // private int numPoints = 50;
    // private double timeScale = 10000;
    // private int FPS = 60;
    // private double k = 1;
    // private double dt = 0.1;
    // private double u = 0.1;

    /* Fourth Test */
    // private int numPoints = 50;
    // private double TPC = 10000;
    // private int FPS = 60;
    // private int TPS = 1000;
    // private int UPT = 1;
    // private double k = 5;
    // private double dt = 0.1;
    // private double u = 0.9;

    /* Fifth Test */
    // private int numPoints = 10;
    // private int TPC = 10000;
    // private int FPS = 60;
    // private int TPS = 1000;
    // private int UPT = 1;
    // private double k = 5;
    // private double dt = 0.1;
    // private double u = 0.9;

    /* Sixth Test */
    private int numPoints = 100;
    private double TPC = 10000;
    private int FPS = 60;
    private int TPS = 100;
    private int UPT = 10;
    private double k = 5;
    private double dt = 0.1;
    private double u = 0.6;

    // TPC - Number of ticks per cycle of the sine wave
    // TPS - Number of ticks per second (Don't make this greater than 1000)
    // UPT - Number of updates per tick (Used to achieve >1000 Updates per second) (Does not affect TPC) (I don't know why I made it this way)
    // k - "Spring Constant" between points (Proportionality constant for acceleration -> velocity)
    // dt - "Time Step" (Proportionality constant for acceleration -> velocity & velocity -> position)
    // u - "Damping Constant" (Will be scaled by velocity and then subtracted) (don't make this greater than 1)
    private int width = 800;
    private double[] wave = new double[numPoints];
    private double[] vels = new double[numPoints];
    private double[] accels = new double[numPoints];
    private int height = 600;
    private double dispScale = 0.3;
    private double initialTime;
    private double target;
    private boolean autoScaleInfo = true; // AutoScales the velocity and acceleration graphs
    private int autoScaleTrim = 2; // Depends on which scaler you're using
    private GlobalMax velsMax = new GlobalMax(autoScaleTrim);
    private GlobalMax accelsMax = new GlobalMax(autoScaleTrim);

    public App() {
        super("WaveSim");
        setSize(width, height);
        addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosing(WindowEvent windowEvent) {
                System.exit(0);
            }
        });
        add(new JPanel() {
            @Override
            public void paintComponent(Graphics graphics) {
                super.paintComponent(graphics);
                doPaint(graphics);
            }
        });
        setResizable(false);
        setVisible(true);
        setSize(getWidth() + getInsets().left + getInsets().right, getHeight() + getInsets().top + getInsets().bottom);
        initialTime = System.currentTimeMillis();
        new Thread(() -> {
            while (true) {
                repaint();
                try {
                    Thread.sleep(1000 / FPS);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).start();
        new Thread(() -> {
            while (true) {
                double deltaPT = 1 / ((double) TPC * UPT);
                double time = (System.currentTimeMillis() - initialTime) * 2 * Math.PI / TPC;
                for(int i = 0; i < UPT; i++) {
                    target = Math.sin(time); // Function to be driven onto the line
                    // First value will be driven onto the left of the line, second value will be driven onto the right of the line
                    // I recommend driving the left side primarily because that will be displayed as a red line on the graph
                    // If you only want to drive a value onto the left, I recommend setting the right to 0 or wave[numPoints-1]
                    updateValues(target, wave[numPoints-1]);
                    accelsMax.add(accels);
                    velsMax.add(vels);
                    time += deltaPT;
                }
                try {
                    Thread.sleep(1000 / TPS);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).start();
        new Thread(() -> {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            velsMax.reset();
            accelsMax.reset();
        }).start();
    }

    public void doPaint(Graphics graphics) {
        Image buf = createImage(getWidth(), getHeight());
        Graphics g = buf.getGraphics();
        g.setColor(getBackground());
        g.fillRect(0, 0, getWidth(), getHeight());

        g.setColor(new Color(0, 255, 0));
        g.drawLine(0, toScreenY(-1), width, toScreenY(-1));
        g.drawLine(0, toScreenY(1), width, toScreenY(1));

        g.setColor(new Color(0, 255, 100));
        plotWave(g, accels, autoScaleInfo ? 1 / accelsMax.getMax() : 1);

        g.setColor(new Color(255, 100, 0));
        plotWave(g, vels, autoScaleInfo ? 1 / velsMax.getMax() : 1);

        g.setColor(new Color(0, 0, 255));
        plotWave(g, wave, 1);

        g.setColor(new Color(255, 0, 0));
        g.drawLine(0, toScreenY(target), 10, toScreenY(target));
        graphics.drawImage(buf, 0, 0, null);
        g.dispose();
    }

    private void plotWave(Graphics g, double[] wave, double scale) {
        for (int i = 0; i < wave.length - 1; i++) {
            g.drawLine(waveScreenX(i), toScreenY(wave[i] * scale), waveScreenX(i + 1), toScreenY(wave[i + 1] * scale));
        }
    }

    private int waveScreenX(int i) {
        return (int) (i * (width / (double) numPoints));
    }

    private int toScreenY(double y) {
        return (int) (height / 2 + y * dispScale * height);
    }

    private void updateValues(double value, double value2) {
        double[] accelsCopy = new double[accels.length];
        System.arraycopy(accels, 0, accelsCopy, 0, accels.length);
        for (int i = 0; i < accels.length; i++) {
            double prev = i == 0 ? value : wave[i - 1];
            double next = i == wave.length - 1 ? value2 : wave[i + 1];
            double forcePrev = (prev - wave[i]) * k;
            double forceNext = (next - wave[i]) * k;
            accels[i] = forcePrev + forceNext;
        }
        double[] velsCopy = new double[vels.length];
        System.arraycopy(vels, 0, velsCopy, 0, vels.length);
        for(int i = 0; i < vels.length; i++) {
            vels[i] += accelsCopy[i] * dt - Math.abs(u) * vels[i];
        }
        for (int i = 0; i < wave.length; i++) {
            wave[i] += velsCopy[i] * dt;
        }
    }

    private void updateValuesSimple(double value) { // Switch to this method if you want the wave to just propagate to the left (it is to the left because that's how CoPilot generated it)
        for (int i = 0; i < wave.length - 1; i++) {
            wave[i] = wave[i + 1];
        }
        wave[wave.length - 1] = value;
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(App::new);
    }
}
